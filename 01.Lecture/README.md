# Bitwise, структуры и библиотеки

## Битовые операции (Bitwise ops)

### Одноместные

```
~ Побитовая инверсия
```

### Двухместные

```
& И
| Или
^ XOR
<< Сдвиг влево
>> Сдвиг вправо
>>> Сдвиг вправо, затем обрезание влево
```

Логические операторы рассматривают любой ненулевой операнд как 1

### Побитовые сдвиги

#### Побитовый сдвиг влево (<<)

сдвиг влево/вправо на 1 эквивалентен умножению/делению на 2:

```
x >> 1 == x / 2
x << 1 == x * 2
```

побитовый сдвиг влево не определён, если:
- если сдвиг превышает операнд
- сдвиг имеет отрицательный знак


#### Побитовый сдвиг вправо (>>)

побитовый сдвиг вправо не определён:

- если сдвиг превышает операнд
- сдвиг имеет отрицательный знак

Если операнд имеет беззнаковый тип — арифметический сдвиг
Когда операнд знаковый — логический сдвиг

##### Арифметический сдвиг

операнд без знака - слева нули

```
11110101
01111010
```

##### Логический сдвиг

операнд со знаком - слева бит знака:
- если бит знака 0, то и слева нули
- если бит знака 1, то и слева единицы

### Исключающее ИЛИ – XOR 
операция при которой результат равен 1, когда только один аргумент равен 1

<img src=pics/01.png width=300>

- x ^ 1=~x (отрицание): Если 
- x ^ x= 0 (самообратимость)
- (x^y)^y=x (реверсивность)

### Побитовое И

Операция при которой результат равен 1, когда оба бита равны 1.

Побитовое И может быть использована для быстрой проверки чётности числа:

```
int32_t x = 17;
(x & 1) ? printf("Odd") : printf("Even");
```

## Структуры с побитовыми полями

Минимально возможный размер структуры в C — 1 байт, с одним полем типа  char.

В языке Си нет возможности создать структуру вида побитовый массив. Поэтому, с добавлением полей, размер структуры будет увеличиваться пропорционально самому большому полю в структуре.

Если записываемое значение превышает размер поля, то получим 0.

## Указатели

Указателями являются переменные, хранящие адрес.

Он имеет одинаковый размер и может хранить адрес для следующих сущностей:

1. переменной
2. другого указателя
3. массива 
4. строки
5. структуры
6. функции

### 1. Указатель на переменную

```
int i=123; // целочисленной переменной присвоили значение
int* pi;   // указательная переменная
pi = &i;   // указательной переменной присвоили адрес ячейки памяти i
```
### 2. Указатель на указатель

```
int **ppi; // указатель на указатель
ppi = &pi; // указателю на указатель присвоили адрес ячейки памяти pi
```

### 3. Указатель на массив

```
int ar[5] = {1,2,3,4,5};
int* pa; // указательная переменная
pa = &ar[0]; // аналогично pa = ar указатель на начало массива
```

#### Указатель на массив в многомерном массиве

```
int str_address = 0; // номер массива в многомерном массиве
int str[3][5] = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}}; // многомерный массив
int (*ps)[5];  // указатель массив в многомерный массив
ps = str+str_address; // получаем указатель на указатель массива внутри многомерного массива
```

### 4. Указатель на строку

```
char string1[] = "Hello, World";  // первый способ объявления строки
char* string2 = "Goodbye, nonsense"; // второй способ объявления строки
int* ps1; // указательная переменная 1
ps1 = string1; // присвоить адрес ячейки памяти string1
int* ps2; // указательная переменная 2
ps2 = string2; // присвоить адрес ячейки памяти string2
printf("%s\n", ps1); // обращение к строке через указатель
printf("%s\n", ps2); // обращение к строке через указатель
```

### 5. Указатель на структуру

При описании структурного типа, память не выделяется. Выделение памяти происходит только после объявления переменных.

```
struct s {
    int i;
    float f;
};

int main(int argc, char const *argv[])
{
    struct s st = {1, 2.0}; // выделение памяти для структуры
    struct s* ps; // создание указательной переменной типа структура
    ps = &st; // указатель на структуру присваивается адрес на структуру
    printf("ps -> i = %d\n", ps->i); // обращение к полю через указатель
    printf("(*ps).f = %f\n", (*ps).f); // второй способ обращения к полю через указатель
    return 0;
}
```

#### Указатель на структуру при передаче в функцию

Указатель на структуру полезен для передачи его в функцию. В противном случае, при передача всей структуры в функцию, она полностью копируется, занимая еще больше места и времени.

```
struct student
{
    int id;
    char name[20];
    int group;
};

void func(struct student record)
{
    printf(" Id is: %d \n", record.id);
    printf(" Name is: %s \n", record.name);
    printf(" Group is: %d \n",
    record.group);
}

void pfunc(struct student *record)
{
    printf(" Id is: %d \n", record->id);
    printf(" Name is: %s \n", record->name);
    printf(" Group is: %d \n",
    record->group);
    }

int main() {
    struct student record = {1, "Vasiliy", 102};
    func(record);
    printf("\n");
    pfunc(&record);
    return 0;
}
```

### 6. Указатель на функцию

```
int func(int n)
{
    printf("Hello func %d\n", n);
    return n + 1;
}

int main()
{
    int (*fp)(int); // указательная переменная на функцию
    fp = func; // присвоить адрес функции func указательной переменной
    fp(5); // передача параметра 5 в функцию через указатель
    return 0;
}
```

#### Callback (Передача функции в функцию)

Передачи функции comparator в функцию qsort

```
typedef int (*comparator_type)(const void *, const void *);
/* сравнение двух целых V2 */
int comparator(const int *a, const int *b)
{
    return *a - *b;
}

int main(void)
{
    int a[3] = {3, 1, 2};
    qsort(a, 3, sizeof(int), (comparator_type)comparator);
    printf("%d,%d,%d", a[0], a[1], a[2]);
}
```

## typedef и #define

### typedef для структуры

Чтобы не писать struct перед типом, можно использовать typedef

```
typedef struct {
    int id; 
    char name[20];
    int group;
} student;

student s;
s.id = 1;
```

### typedef для массива

```
typedef int iarr[10];
int id; iarr a, b, c[5];
char name[20]; // то же самое int a[10], b[10], c[10][5];
```

### #define

```
#define float double; typedef double float;
float f = 1.23;
```

## Библиотеки

Библиотеки могут существовать в двух вариациях:
- статические: код из библиотеки добавляется в исполняемый файл на стадии линковки, и после её окончания файл библиотеки больше не нужен полученной программе
- динамические: код из библиотеки не добавляется в исполняемый файл, а загружается в память во время запуска программы. Таким образом, он должен быть доступен при каждом запуске

Стандартные библиотеки С, которые рассмотрим:

1. locale.h — библиотека локализации
2. time.h — библиотека для работы со временем
3. ncurses.h — библиотека для вывода тестовой информации на терминал
4. stdio.h — библиотека ввода/вывода
5. string.h — библиотека для работы со строками
6. assert.h — библиотека для вывода диагностической информации

### 1. locale.h

- setlocale(int category, const char* locale) - Функция установки локали

- **wchar_t** занимает 4 байта и хранится в памяти в виде целого числа (код символа), в порядке big-endian.

```
#include <stdio.h>
#include <locale.h> //setlocale()
#include <wchar.h> //«широкие» символы

int main()
{
    setlocale(LC_ALL,"en_US.UTF-8");
    wchar_t str1[] = L"Привет";
    printf("str1 = %S\n", str1);
    printf("sizeof str1 = %lu\n", sizeof(str1)); // размер 28 байт
    char str2[] = "Привет";
    printf("str2 = %s\n",str2);
    printf("sizeof str2 = %lu\n", sizeof(str2)); // размер 13 байт
    char str3[] = "Hello!";                     // размер 7 байт
    printf("str3 = %s\n",str3);
    printf("sizeof str3 = %lu\n", sizeof(str3));
    return 0;
}
```

#### UTF-8

UTF-8 разработан для обратной совместимости с ASCII: первые 128 символов Unicode, которые взаимно-однозначно соответствуют ASCII, кодируются с использованием одного байта с тем же двоичным значением, что и ASCII. Поэтому действительный текст ASCII является действительным UTF-8. — кодированным Unicode.

Символы с более низкими числовыми значениями, которые, как правило, встречаются чаще, кодируются с
использованием меньшего количества байтов (1). Символы с более высокими числовыми значениями, которые
встречаются реже, кодируются с использованием большего количества байтов (4).

```
uint8_t ch[] = {0xd0,0x90,0xd0,0x91}; // "АБ"
uint32_t ch32[] = {0x91d090d0,0}; // "АБ"
printf("%x %x %x %x = %s\n",ch[0],ch[1],ch[2],ch[3],ch);
printf("%x = %s\n",ch32[0], ch32);
```

Чтобы декодировать UTF-8, нужно посмотреть первые (самые старшие) 2 бита каждого байта. Если они «01» или «00», — это 8-битный символьный код, если они «11», — это первый байт многобайтовой последовательности. Если они равны «10», то это один байт внутри многобайтовой последовательности. В следующем примере проверяем первый байт UTF-8 символа: он показывает, сколько всего байт в символе.

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

    int numberOfBytesInChar(unsigned char val) {
    if (val < 128) {
        return 1;
    } else if (val < 224) {
        return 2;
    } else if (val < 240) {
        return 3;
    } else {
        return 4;
    }
}

int utf8strlen(char *s) {
    char *tmp = s;
    int len = 0;
    while( *tmp ) {
    tmp += numberOfBytesInChar(*tmp);
    len++;
    // len += (*tmp++ & 0xC0) != 0x80;
    // *tmp++ & 0xC0 проверяем шаблон 11xxxxxx
    // !=0x80 не является 10xxxxxx
    //или внутренним байтом UTF-8 символа
    }
    return len;
}

int main(){
    char s[] = "Hello world";
    char s2[] = "Привет Мир";
    printf("strlen(s2) = %lu\n",strlen(s2));
    printf("utf8strlen(s) = %d\n",utf8strlen(s));
    printf("utf8strlen(s2) = %d\n",utf8strlen(s2));
    return 0;
}
```

Еще один вариант. Анализируем все байты кроме тех, которые являются внутренними байтами UTF-8 символа. Такие байты удовлетворяют маске 0b10xxxxxx, их необходимо пропускать при подсчете длины.

```
#include <stdio.h>

size_t strlenutf8(char *s)
{
    size_t length = 0;
    while (*s)
    {
        if ((*s & 0b11000000) != 0b10000000)
        {
            ++length;
        }
        ++s;
    }
    return length;
}

int main()
{
    char s[] = "Привет";
    char s2[] = "Hello";
    printf("len s = %zu\n", strlenutf8(s));
    printf("len s2 = %zu\n",
           strlenutf8(s2));
    return 0;
}
```

### 2. time.h

Возврат текущего времени, в структуре типа time_t:

```
time_t mytime = time(NULL);
```

Извлечение даты и времени из структуры типа time_t:

```
struct tm* now = localtime(&mytime);
printf("%02d:%02d:%02d\n", now->tm_hour, now->tm_min, now->tm_sec);
```

Код вывода в консоль текущей даты и времени:

```
#include <stdio.h>
#include <time.h>

int main(void)
{
    time_t mytime = time(NULL);
    struct tm *now = localtime(&mytime);
    printf("Date: %d.%d.%d\n", now->tm_mday,
           now->tm_mon + 1, now->tm_year + 1900);
    printf("Time: %d:%d:%d\n", now->tm_hour,
           now->tm_min, now->tm_sec);
    return 0;
}
```

Замер скорости выполнения программы с точностью до микросекунд:

```
double DELAY = 3;
clock_t begin = clock();
while((double)(clock() - begin)/CLOCKS_PER_SEC<DELAY)
    {/*printf("%4d\n",clock());*/ }
printf("Hello World %ld",CLOCKS_PER_SEC);
```

### 3. ncurses.h

Предоставляет функции для перемещения курсора, создания окон, создания цветов, игры с мышью и т. д.

Для работы библиотеки нужно установить зависимости:

- Windows https://pdcurses.org/, запустить файл mingw32-make для сборки в каталоге \wincon
- Linux ```sudo apt-get install libncursesw5-dev```

```
#include <ncurses.h>
int main()
{
    int ch;
    initscr(); // Начать curses mode
    raw();
    // Отключаем buffering. Ctrl+C не завершит программу
    noecho(); // Отключаем echo() режим пока считываем символы
    getch();
    printw("Type text: \n");
    while ((ch = getch()) != '.')
    {
        printw("%c", ch);
    }
    // refresh(); // Печатаем это на экран
    getch();
    // Ждем пока пользователь нажмет клавишу
    endwin(); // Завершить curses mode
    return 0;
}
```

Для компиляции программы нужно включить `-lncurses`:

```
gcc -o prog 18.c -lncurses
```

