# Побитовые операции, поля и структуры

## Битовые операции

### Одноместные

```
~ Побитовая инверсия
```

### Двухместные

```
& И
| Или
^ XOR
<< Сдвиг влево
>> Сдвиг вправо
>>> Сдвиг вправо, затем обрезание влево
```

Логические операторы рассматривают любой ненулевой операнд как 1

### Побитовые сдвиги

#### Побитовый сдвиг влево (<<)

сдвиг влево/вправо на 1 эквивалентен умножению/делению на 2:

```
x >> 1 == x / 2
x << 1 == x * 2
```

побитовый сдвиг влево не определён, если:
- если сдвиг превышает операнд
- сдвиг имеет отрицательный знак


#### Побитовый сдвиг вправо (>>)

побитовый сдвиг вправо не определён:

- если сдвиг превышает операнд
- сдвиг имеет отрицательный знак

Если операнд имеет беззнаковый тип — арифметический сдвиг
Когда операнд знаковый — логический сдвиг

##### Арифметический сдвиг

операнд без знака - слева нули

```
11110101
01111010
```

##### Логический сдвиг

операнд со знаком - слева бит знака:
- если бит знака 0, то и слева нули
- если бит знака 1, то и слева единицы

### Исключающее ИЛИ – XOR 
операция при которой результат равен 1, когда только один аргумент равен 1

<img src=pics/01.png width=300>

- x ^ 1=~x (отрицание): Если 
- x ^ x= 0 (самообратимость)
- (x^y)^y=x (реверсивность)

### Побитовое И

Операция при которой результат равен 1, когда оба бита равны 1.

Побитовое И может быть использована для быстрой проверки чётности числа:

```
int32_t x = 17;
(x & 1) ? printf("Odd") : printf("Even");
```

## Структуры с побитовыми полями

Минимально возможный размер структуры в C — 1 байт, с одним полем типа  char.

В языке Си нет возможности создать структуру вида побитовый массив. Поэтому, с добавлением полей, размер структуры будет увеличиваться пропорционально самому большому полю в структуре.

Если записываемое значение превышает размер поля, то получим 0.

## Указатели

Указателями являются переменные, хранящие адрес.

Он имеет одинаковый размер и может хранить адрес для следующих сущностей:

1. переменной
2. другого указателя
3. массива 
4. строки
5. структуры
6. функции

### 1. Указатель на переменную

```
int i=123; // целочисленной переменной присвоили значение
int* pi;   // указательная переменная
pi = &i;   // указательной переменной присвоили адрес ячейки памяти i
```
### 2. Указатель на указатель

```
int **ppi; // указатель на указатель
ppi = &pi; // указателю на указатель присвоили адрес ячейки памяти pi
```

### 3. Указатель на массив

```
int ar[5] = {1,2,3,4,5};
int* pa; // указательная переменная
pa = &ar[0]; // аналогично pa = ar указатель на начало массива
```

#### Указатель на массив в многомерном массиве

```
int str_address = 0; // номер массива в многомерном массиве
int str[3][5] = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}}; // многомерный массив
int (*ps)[5];  // указатель массив в многомерный массив
ps = str+str_address; // получаем указатель на указатель массива внутри многомерного массива
```

### 4. Указатель на строку

```
char string1[] = "Hello, World";  // первый способ объявления строки
char* string2 = "Goodbye, nonsense"; // второй способ объявления строки
int* ps1; // указательная переменная 1
ps1 = string1; // присвоить адрес ячейки памяти string1
int* ps2; // указательная переменная 2
ps2 = string2; // присвоить адрес ячейки памяти string2
printf("%s\n", ps1); // обращение к строке через указатель
printf("%s\n", ps2); // обращение к строке через указатель
```

### 5. Указатель на структуру

При описании структурного типа, память не выделяется. Выделение памяти происходит только после объявления переменных.

```
struct s {
    int i;
    float f;
};

int main(int argc, char const *argv[])
{
    struct s st = {1, 2.0}; // выделение памяти для структуры
    struct s* ps; // создание указательной переменной типа структура
    ps = &st; // указатель на структуру присваивается адрес на структуру
    printf("ps -> i = %d\n", ps->i); // обращение к полю через указатель
    printf("(*ps).f = %f\n", (*ps).f); // второй способ обращения к полю через указатель
    return 0;
}
```

#### Указатель на структуру при передаче в функцию

Указатель на структуру полезен для передачи его в функцию. В противном случае, при передача всей структуры в функцию, она полностью копируется, занимая еще больше места и времени.

```
struct student
{
    int id;
    char name[20];
    int group;
};

void func(struct student record)
{
    printf(" Id is: %d \n", record.id);
    printf(" Name is: %s \n", record.name);
    printf(" Group is: %d \n",
    record.group);
}

void pfunc(struct student *record)
{
    printf(" Id is: %d \n", record->id);
    printf(" Name is: %s \n", record->name);
    printf(" Group is: %d \n",
    record->group);
    }

int main() {
    struct student record = {1, "Vasiliy", 102};
    func(record);
    printf("\n");
    pfunc(&record);
    return 0;
}
```

### 6. Указатель на функцию

```
int func(int n)
{
    printf("Hello func %d\n", n);
    return n + 1;
}

int main()
{
    int (*fp)(int); // указательная переменная на функцию
    fp = func; // присвоить адрес функции func указательной переменной
    fp(5); // передача параметра 5 в функцию через указатель
    return 0;
}
```

#### Callback (Передача функции в функцию)

Передачи функции comparator в функцию qsort

```
typedef int (*comparator_type)(const void *, const void *);
/* сравнение двух целых V2 */
int comparator(const int *a, const int *b)
{
    return *a - *b;
}

int main(void)
{
    int a[3] = {3, 1, 2};
    qsort(a, 3, sizeof(int), (comparator_type)comparator);
    printf("%d,%d,%d", a[0], a[1], a[2]);
}
```

## typedef и #define

### typedef для структуры

Чтобы не писать struct перед типом, можно использовать typedef

```
typedef struct {
    int id; 
    char name[20];
    int group;
} student;

student s;
s.id = 1;
```

### typedef для массива

```
typedef int iarr[10];
int id; iarr a, b, c[5];
char name[20]; // то же самое int a[10], b[10], c[10][5];
```

### #define

```
#define float double; typedef double float;
float f = 1.23;
```